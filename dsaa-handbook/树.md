## 堆
堆满足结构性和堆序性。结构性指堆满足完全二叉树，堆序性指每个父节点小于（大于）所有子节点。堆的操作主要有**插入**和**删除**。根据预先定义的性质，可以删除最小值或最大值，一般都位于堆的根部。

堆的两项操作十分容易理解。以下以小顶堆为例。

插入：当插入一项元素时，可能会打破堆序性。重复以下步骤即可保持堆序性：将插入项与父节点对比，如果要小，就交换位置；否则插入成功。以上步骤应该是很符合直觉的。新插入项的位置可以看作是一个洞（hole），它被逐层上移，直至满足要求。这种策略被称为上滤（percolate up）。

删除：删除最小项必然打破结构性。要保持结构性，唯一的解决办法是用最后一项填充这个空洞。不过这样做可能会打破堆序性，有个更好的类似思路。将这个空洞往下移动，移动到合适位置之后再用堆的最后一项填充这个空洞。具体步骤是：与洞的子节点中较小者交换位置，以此类推，直至合适位置。这被称为下滤（percolate down）。需要注意的是，以上步骤并不难编写，比较复杂的是几个判断条件。例如，要判断子节点的最小者的前提是空洞必须存在两个节点；空洞并不需要到底部，当堆的最后一项小于空洞子节点即可停止下滤。

堆的另一个比较重要的操作是**构建堆**。具体来说，只要在最后第二层逐个往前执行下滤操作直至根部，就能构建堆，具体顺序是从右往左，从下往上。这可以看成保证每个子堆都满足结构性和堆序性。这样做的时间复杂度是 $O(n)$，还有种简单直观的做法是从单节点堆开始插入新节点，不过时间复杂度是 $O(n \log n)$。

**合并**两个堆的操作主要有两种方式：1）在大堆中依次插入小堆的项；2）重新构建一个堆。不过两种方式的时间复杂度都很高，如果合并操作频发，建议使用左式堆、斜堆等结构。

